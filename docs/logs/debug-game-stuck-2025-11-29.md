# 游戏卡住问题调试记录

**日期**: 2025-11-29  
**时间**: 17:20 - 17:30  
**问题**: 游戏卡在等待循环，无法进入

---

## 🔍 问题现象

### Super Mario Bros
- **PC 卡在**: 0x952b (死循环)
- **寄存器**: A=0, X=0, Y=0 (从未变化)
- **画面**: 静止不变
- **输入**: 按键被检测但游戏不响应

### Donkey Kong
- **PC**: 在变化 (0xa, 0x6a, 等)
- **行为**: 类似，不读取控制器
- **画面**: 静止不变

---

## 🧪 调试过程

### 1. 检查控制器读取
**方法**: 监控 $4016 访问  
**结果**: ❌ 游戏从未读取控制器  
**结论**: 游戏还没到检查输入的阶段

### 2. 检查 PPU 寄存器读取
**方法**: 监控所有 PPU 寄存器读取  
**结果**: ❌ 完全没有 PPU 读取  
**结论**: 游戏没有读取 PPUSTATUS

### 3. 检查 NMI 触发
**方法**: 监控 NMI 信号  
**结果**: ❌ NMI 从未触发  
**结论**: 这是问题的关键

### 4. 检查 VBlank 标志
**方法**: 监控 VBlank 设置  
**结果**: ❓ printf 没有输出（可能被优化）  
**结论**: 无法确认 VBlank 是否工作

### 5. 强制启用 NMI
**方法**: 设置 `forceNmiEnable = true.B`  
**结果**: ❌ PC 仍然卡在 0x952b  
**结论**: 问题不是 NMI enable

---

## 💡 可能的原因

### 1. VBlank 从未设置 🔴 最可能
**原因**: 
- PPU 的 scanline/pixel 计数可能不工作
- VBlank 条件 (scanline === 241.U && pixel === 1.U) 从未满足
- PPU 可能根本没有运行

**证据**:
- 强制 NMI enable 也没用
- 没有任何 PPU 活动迹象

**验证方法**:
- 检查 PPU clock 连接
- 验证 scanline/pixel 是否在计数
- 使用 VCD 波形查看

### 2. NMI 信号未传递到 CPU 🟠
**原因**:
- NMI 连接可能有问题
- CPU 的 NMI 输入可能未正确处理

**证据**:
- 即使强制 NMI 也不工作

**验证方法**:
- 检查 Verilog 中的 NMI 连接
- 测试 CPU 的 NMI 响应

### 3. CPU NMI 处理有问题 🟡
**原因**:
- CPU 可能没有实现 NMI 处理
- NMI 向量可能不正确

**证据**:
- PC 完全不变

**验证方法**:
- 检查 CPU6502Refactored 的 NMI 实现
- 测试 NMI 向量读取

---

## 🔧 已尝试的修复

1. ✅ 实现控制器 strobe 协议
2. ✅ 添加各种调试输出
3. ✅ 强制启用 NMI
4. ❌ 都没有解决问题

---

## 🎯 下一步行动

### 优先级 1: 验证 PPU 是否运行 🔴

**方法**:
1. 在 testbench 中读取 PPU 的 scanline/pixel 值
2. 验证它们是否在计数
3. 如果不计数，检查 PPU clock

**代码**:
```cpp
// testbench_main.cpp
printf("PPU: scanline=%d pixel=%d\n", 
       dut->ppu->scanline, dut->ppu->pixel);
```

### 优先级 2: 检查 CPU NMI 实现 🟠

**方法**:
1. 查看 CPU6502Refactored 的 NMI 处理代码
2. 验证 NMI 向量 ($FFFA-$FFFB) 是否正确
3. 测试 CPU 是否响应 NMI

### 优先级 3: 使用 VCD 波形分析 🟡

**方法**:
1. 编译带 trace 的版本
2. 生成 VCD 文件
3. 查看 NMI 信号、VBlank 标志、scanline 等

---

## 📊 当前状态

### 已知工作的部分
- ✅ ROM 加载
- ✅ CPU 基本执行
- ✅ PPU 渲染（能显示图形）
- ✅ 输入检测

### 不工作的部分
- ❌ VBlank 触发（可能）
- ❌ NMI 触发
- ❌ 游戏主循环
- ❌ 输入响应

### 阻塞问题
**NMI 不工作** - 这是让游戏运行的关键

---

## 💭 技术分析

### NES 游戏启动流程

1. **Reset** → CPU 从 Reset Vector ($FFFC-$FFFD) 开始
2. **初始化** → 设置 PPU、APU、内存
3. **等待 VBlank** → 游戏进入等待循环 ← **我们卡在这里**
4. **NMI 触发** → VBlank 开始，NMI 中断
5. **NMI 处理** → 更新游戏逻辑、检查输入
6. **主循环** → 重复步骤 3-5

### 为什么游戏需要 VBlank？

- **同步**: 游戏逻辑与屏幕刷新同步
- **安全**: 只在 VBlank 期间更新 PPU
- **时序**: 每帧执行一次游戏逻辑

### 0x952b 是什么？

可能是：
```assembly
loop:
    JMP loop    ; 0x952b: 4C 2B 95
```

游戏在等待 NMI 中断来跳出这个循环。

---

## 🔬 需要的工具

1. **VCD 波形查看器** - 查看信号时序
2. **6502 反汇编器** - 分析 ROM 代码
3. **更好的调试输出** - printf 可能被优化

---

## 📝 结论

**根本问题**: NMI 不工作

**最可能原因**: PPU 的 VBlank 从未触发

**下一步**: 验证 PPU 是否在运行，scanline 是否在计数

**预计时间**: 30-60 分钟

---

**调试时间**: 10 分钟  
**状态**: 🔴 问题未解决  
**优先级**: 最高
