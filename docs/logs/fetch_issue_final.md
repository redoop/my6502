# Fetch 预读问题 - 最终状态

## 问题总结

**核心问题**: JSR 跳转地址错误
- 期望: JSR $FFA2 → 跳转到 0xFFA2
- 实际: JSR $FFA2 → 跳转到 0xEF92

## 根本原因

**SyncReadMem 延迟**: Chisel 的 SyncReadMem 有 1 周期读取延迟
- Fetch 预读在 cycle 2 读取数据
- 但 SyncReadMem 要到 cycle 3 才返回数据
- 导致 operand 保存的是错误的值

## 尝试的解决方案

### 1. 移除 Fetch 预读 ❌
- 结果: 测试失败，Verilator 卡住
- 原因: 指令期望预读的数据

### 2. 恢复预读并修复指令 ❌
- 结果: 测试通过，但 Verilator 仍然跳转错误
- 原因: SyncReadMem 延迟

### 3. 指令忽略预读，自己读取 ❌
- 结果: 仍然跳转错误
- 原因: 问题可能不在预读

## 可能的其他原因

1. **内存映射问题**: ROM 地址映射错误
2. **字节序问题**: 大端/小端混淆
3. **PC 更新时序**: PC 在错误的时间更新
4. **Verilator 仿真问题**: testbench 的内存模型有 bug

## 建议

### 短期 (1-2 小时)
1. 使用组合逻辑内存 (Mem 而不是 SyncReadMem)
2. 添加详细的内存读取日志
3. 创建简单的 ROM 测试 JSR

### 中期 (半天)
1. 重新设计 Fetch 机制，适应 SyncReadMem 延迟
2. 添加额外的等待周期
3. 完整测试所有指令

### 长期 (1 天)
1. 使用流水线设计
2. 优化内存访问
3. 实现预取缓冲

## 当前状态

**测试**: 119/122 通过 (97.5%)
- ✅ 大部分指令测试通过
- ❌ 3 个时序相关测试失败

**Verilator**: ❌ 不工作
- CPU 跳转到错误地址
- 游戏无法运行

## 时间投入

- Fetch 重构: 2 小时
- 调试 JSR/JMP: 2 小时
- **总计**: 4 小时

## 推荐行动

**停止当前方向**，采用以下策略之一：

1. **回退到工作版本** (15 分钟)
   - 恢复到时序修复前的代码
   - 接受 Fetch 预读的限制
   - 专注于其他问题

2. **使用组合逻辑内存** (1 小时)
   - 将 SyncReadMem 改为 Mem
   - 移除读取延迟
   - 重新测试

3. **暂停 NES 项目** (0 分钟)
   - 当前设计有根本性问题
   - 需要重新评估架构
   - 考虑使用现有的 6502 实现

## 结论

Fetch 预读与 SyncReadMem 延迟不兼容。需要：
- 要么移除预读
- 要么使用组合逻辑内存
- 要么重新设计 Fetch 机制

当前的修复尝试已经超出合理时间投入。建议回退或暂停。
